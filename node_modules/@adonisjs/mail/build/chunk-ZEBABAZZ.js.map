{"version":3,"sources":["../src/message.ts","../src/base_mail.ts","../src/mailer.ts","../configure.ts","../src/fake_mailer.ts","../src/mail_manager.ts","../src/define_config.ts"],"sourcesContent":["/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { basename } from 'node:path'\nimport { Readable } from 'node:stream'\nimport { fileURLToPath } from 'node:url'\nimport Macroable from '@poppinss/macroable'\nimport { AssertionError } from 'node:assert'\nimport { cuid } from '@adonisjs/core/helpers'\nimport type { SendMailOptions } from 'nodemailer'\nimport { RuntimeException } from '@poppinss/utils'\nimport ical, { type ICalCalendar } from 'ical-generator'\nimport { Attachment, ListHeader } from 'nodemailer/lib/mailer/index.js'\n\nimport debug from './debug.js'\nimport type {\n  Recipient,\n  AttachmentOptions,\n  NodeMailerMessage,\n  CalendarEventOptions,\n  MessageBodyTemplates,\n  MailerTemplateEngine,\n} from './types.js'\n\n/**\n * Fluent API to construct node mailer message object\n */\nexport class Message extends Macroable {\n  static templateEngine?: MailerTemplateEngine\n\n  /**\n   * Use the configured template engine to compute\n   * the email contents from templates\n   */\n  static async computeContentsFor({\n    message,\n    views,\n  }: {\n    message: NodeMailerMessage\n    views: MessageBodyTemplates\n  }) {\n    const getTemplateEngine = () => {\n      if (!this.templateEngine) {\n        throw new RuntimeException('Cannot render email templates without a template engine')\n      }\n      return this.templateEngine\n    }\n\n    /**\n     * Helpers to be shared with templates\n     */\n    const viewHelpers = {\n      embedImage: (filePath: string, options?: any) => {\n        const cid = cuid()\n        message.attachments = message.attachments || []\n\n        message.attachments.push({\n          path: filePath,\n          cid,\n          filename: basename(filePath),\n          ...options,\n        })\n\n        return `cid:${cid}`\n      },\n      embedImageData: (data: Buffer | Readable, options?: any) => {\n        const cid = cuid()\n        message.attachments = message.attachments || []\n\n        message.attachments.push({\n          content: data,\n          cid,\n          ...options,\n        })\n\n        return `cid:${cid}`\n      },\n    }\n\n    if (!message.html && views.html) {\n      debug('computing mail html contents %O', views.html)\n      message.html = await getTemplateEngine().render(\n        views.html.template,\n        viewHelpers,\n        views.html.data\n      )\n    }\n\n    /**\n     * Do not share view helpers with text image, since they cannot\n     * render images\n     */\n    if (!message.text && views.text) {\n      debug('computing mail text contents %O', views.text)\n      message.text = await getTemplateEngine().render(views.text.template, {}, views.text.data)\n    }\n\n    if (!message.watch && views.watch) {\n      debug('computing mail watch contents %O', views.watch)\n      message.watch = await getTemplateEngine().render(\n        views.watch.template,\n        viewHelpers,\n        views.watch.data\n      )\n    }\n  }\n\n  /**\n   * Nodemailer internally mutates the \"attachments\" object\n   * and removes the path property with the contents of\n   * the file.\n   *\n   * Therefore, we need an additional attachment array we can\n   * use to searching attachments and writing assertions\n   */\n  #attachmentsForSearch: Attachment[] = []\n\n  /**\n   * Templates to use for rendering email body for\n   * HTML, plain text and watch\n   */\n  contentViews: MessageBodyTemplates = {}\n\n  /**\n   * Reference to the underlying node mailer message\n   */\n  nodeMailerMessage: NodeMailerMessage = {}\n\n  /**\n   * Converts a recipient email and name to formatted\n   * string\n   */\n  protected formatRecipient(recipient?: Recipient) {\n    if (!recipient) {\n      return undefined\n    }\n\n    if (typeof recipient === 'string') {\n      return recipient\n    }\n\n    if (!recipient.name) {\n      return recipient.address\n    }\n\n    return `${recipient.name} <${recipient.address}>`\n  }\n\n  /**\n   * Check if a given recipient exists for the mentioned\n   * email and name.\n   */\n  hasRecipient(property: 'to' | 'cc' | 'bcc' | 'replyTo', address: string, name?: string) {\n    const recipients = this.nodeMailerMessage[property]\n    if (!recipients) {\n      return false\n    }\n\n    /**\n     * When checking for name and email both\n     */\n    if (name) {\n      return !!recipients.find((recipient) => {\n        if (typeof recipient === 'string') {\n          return false\n        }\n        return recipient.address === address && recipient.name === name\n      })\n    }\n\n    /**\n     * When checking for just the email\n     */\n    return !!recipients.find((recipient) => {\n      if (typeof recipient === 'string') {\n        return recipient === address\n      }\n      return recipient.address === address\n    })\n  }\n\n  /**\n   * Assert the message is sent to the mentioned address\n   */\n  assertRecipient(property: 'to' | 'cc' | 'bcc' | 'replyTo', address: string, name?: string) {\n    if (!this.hasRecipient(property, address, name)) {\n      const expected = this.formatRecipient({ address, name: name || '' })\n      const actual =\n        this.nodeMailerMessage[property]?.map((recipient) => {\n          return this.formatRecipient(recipient)\n        }) || []\n\n      throw new AssertionError({\n        message: `Expected message to be delivered to \"${expected}\"`,\n        expected: [expected],\n        actual,\n        operator: 'includes',\n      })\n    }\n  }\n\n  /**\n   * Add recipient as `to`\n   */\n  to(address: string, name?: string): this {\n    this.nodeMailerMessage.to = this.nodeMailerMessage.to || []\n    this.nodeMailerMessage.to.push(name ? { address, name } : address)\n    return this\n  }\n\n  /**\n   * Check if message is sent to the mentioned address\n   */\n  hasTo(address: string, name?: string): boolean {\n    return this.hasRecipient('to', address, name)\n  }\n\n  /**\n   * Assert the message is sent to the mentioned address\n   */\n  assertTo(address: string, name?: string) {\n    return this.assertRecipient('to', address, name)\n  }\n\n  /**\n   * Add `from` name and email\n   */\n  from(address: string, name?: string): this {\n    this.nodeMailerMessage.from = name ? { address, name } : address\n    return this\n  }\n\n  /**\n   * Check if message is sent from the mentioned address\n   */\n  hasFrom(address: string, name?: string): boolean {\n    const fromAddress = this.nodeMailerMessage.from\n    if (!fromAddress) {\n      return false\n    }\n\n    /**\n     * When checking for name and email both\n     */\n    if (name) {\n      if (typeof fromAddress === 'string') {\n        return false\n      }\n      return fromAddress.address === address && fromAddress.name === name\n    }\n\n    /**\n     * When checking for just the email\n     */\n    if (typeof fromAddress === 'string') {\n      return fromAddress === address\n    }\n    return fromAddress.address === address\n  }\n\n  /**\n   * Assert the message is sent from the mentioned address\n   */\n  assertFrom(address: string, name?: string) {\n    if (!this.hasFrom(address, name)) {\n      const expected = this.formatRecipient({ address, name: name || '' })\n      const actual = this.formatRecipient(this.nodeMailerMessage.from)\n\n      throw new AssertionError({\n        message: `Expected message to be sent from \"${expected}\"`,\n        expected,\n        actual,\n      })\n    }\n  }\n\n  /**\n   * Add recipient as `cc`\n   */\n  cc(addresses: string[]): this\n  cc(addresses: { address: string; name: string }[]): this\n  cc(address: string, name?: string): this\n  cc(addresses: string | string[] | { address: string; name: string }[], name?: string): this {\n    this.nodeMailerMessage.cc = this.nodeMailerMessage.cc || []\n    if (typeof addresses === 'string') {\n      this.nodeMailerMessage.cc.push(name ? { address: addresses, name } : addresses)\n    } else {\n      addresses.forEach((address) => {\n        this.nodeMailerMessage.cc!.push(address)\n      })\n    }\n    return this\n  }\n\n  /**\n   * Check if message is sent to the mentioned address\n   */\n  hasCc(address: string, name?: string): boolean {\n    return this.hasRecipient('cc', address, name)\n  }\n\n  /**\n   * Assert the message is sent to the mentioned address\n   */\n  assertCc(address: string, name?: string) {\n    return this.assertRecipient('cc', address, name)\n  }\n\n  /**\n   * Add recipient as `bcc`\n   */\n  bcc(addresses: string[]): this\n  bcc(addresses: { address: string; name: string }[]): this\n  bcc(address: string, name?: string): this\n  bcc(addresses: string | string[] | { address: string; name: string }[], name?: string): this {\n    this.nodeMailerMessage.bcc = this.nodeMailerMessage.bcc || []\n    if (typeof addresses === 'string') {\n      this.nodeMailerMessage.bcc.push(name ? { address: addresses, name } : addresses)\n    } else {\n      addresses.forEach((address) => {\n        this.nodeMailerMessage.bcc!.push(address)\n      })\n    }\n    return this\n  }\n\n  /**\n   * Check if message is sent to the mentioned address\n   */\n  hasBcc(address: string, name?: string): boolean {\n    return this.hasRecipient('bcc', address, name)\n  }\n\n  /**\n   * Assert the message is sent to the mentioned address\n   */\n  assertBcc(address: string, name?: string) {\n    return this.assertRecipient('bcc', address, name)\n  }\n\n  /**\n   * Define custom message id\n   */\n  messageId(messageId: string): this {\n    this.nodeMailerMessage.messageId = messageId\n    return this\n  }\n\n  /**\n   * Define subject\n   */\n  subject(message: string): this {\n    this.nodeMailerMessage.subject = message\n    return this\n  }\n\n  /**\n   * Check if the message has the mentioned subject\n   */\n  hasSubject(message: string): boolean {\n    return !!this.nodeMailerMessage.subject && this.nodeMailerMessage.subject === message\n  }\n\n  /**\n   * Assert the message has the mentioned subject\n   */\n  assertSubject(message: string) {\n    if (!this.hasSubject(message)) {\n      throw new AssertionError({\n        message: `Expected message subject to be \"${message}\"`,\n        expected: message,\n        actual: this.nodeMailerMessage.subject,\n      })\n    }\n  }\n\n  /**\n   * Define replyTo email and name\n   */\n  replyTo(address: string, name?: string): this {\n    this.nodeMailerMessage.replyTo = this.nodeMailerMessage.replyTo || []\n    this.nodeMailerMessage.replyTo.push(name ? { address, name } : address)\n    return this\n  }\n\n  /**\n   * Check if the mail has the mentioned reply to address\n   */\n  hasReplyTo(address: string, name?: string): boolean {\n    return this.hasRecipient('replyTo', address, name)\n  }\n\n  /**\n   * Assert the mail has the mentioned reply to address\n   */\n  assertReplyTo(address: string, name?: string) {\n    if (!this.hasRecipient('replyTo', address, name)) {\n      const expected = this.formatRecipient({ address, name: name || '' })\n      const actual =\n        this.nodeMailerMessage.replyTo?.map((recipient) => {\n          return this.formatRecipient(recipient)\n        }) || []\n\n      throw new AssertionError({\n        message: `Expected reply-to addresses to include \"${expected}\"`,\n        expected: [expected],\n        actual,\n        operator: 'includes',\n      })\n    }\n  }\n\n  /**\n   * Define inReplyTo message id\n   */\n  inReplyTo(messageId: string): this {\n    this.nodeMailerMessage.inReplyTo = messageId\n    return this\n  }\n\n  /**\n   * Define multiple message id's as references\n   */\n  references(messagesIds: string[]): this {\n    this.nodeMailerMessage.references = messagesIds\n    return this\n  }\n\n  /**\n   * Optionally define email envolpe\n   */\n  envelope(envelope: SendMailOptions['envelope']): this {\n    this.nodeMailerMessage.envelope = envelope\n    return this\n  }\n\n  /**\n   * Define contents encoding\n   */\n  encoding(encoding: string): this {\n    this.nodeMailerMessage.encoding = encoding\n    return this\n  }\n\n  /**\n   * Define email prority\n   */\n  priority(priority: 'low' | 'normal' | 'high'): this {\n    this.nodeMailerMessage.priority = priority\n    return this\n  }\n\n  /**\n   * Compute email html from defined view\n   */\n  htmlView(template: string, data?: any): this {\n    this.contentViews.html = { template, data }\n    return this\n  }\n\n  /**\n   * Compute email text from defined view\n   */\n  textView(template: string, data?: any): this {\n    this.contentViews.text = { template, data }\n    return this\n  }\n\n  /**\n   * Compute apple watch html from defined view\n   */\n  watchView(template: string, data?: any): this {\n    this.contentViews.watch = { template, data }\n    return this\n  }\n\n  /**\n   * Compute email html from raw text\n   */\n  html(content: string): this {\n    this.nodeMailerMessage.html = content\n    return this\n  }\n\n  /**\n   * Compute email text from raw text\n   */\n  text(content: string): this {\n    this.nodeMailerMessage.text = content\n    return this\n  }\n\n  /**\n   * Compute email watch html from raw text\n   */\n  watch(content: string): this {\n    this.nodeMailerMessage.watch = content\n    return this\n  }\n\n  /**\n   * Assert content of mail to include substring or match\n   * a given regular expression\n   */\n  assertContent(property: 'text' | 'watch' | 'html', substring: string | RegExp) {\n    const contents = this.nodeMailerMessage[property]\n    if (!contents) {\n      throw new AssertionError({\n        message: `Expected message ${property} body to match substring, but it is undefined`,\n      })\n    }\n\n    if (typeof substring === 'string') {\n      if (!String(contents).includes(substring)) {\n        throw new AssertionError({\n          message: `Expected message ${property} body to include \"${substring}\"`,\n        })\n      }\n      return\n    }\n\n    if (!substring.test(String(contents))) {\n      throw new AssertionError({\n        message: `Expected message ${property} body to match \"${substring}\"`,\n      })\n    }\n  }\n\n  /**\n   * Assert message plain text contents to include\n   * substring or match the given regular expression\n   */\n  assertTextIncludes(substring: string | RegExp) {\n    return this.assertContent('text', substring)\n  }\n\n  /**\n   * Assert message HTML contents to include substring\n   * or match the given regular expression\n   */\n  assertHtmlIncludes(substring: string | RegExp) {\n    return this.assertContent('html', substring)\n  }\n\n  /**\n   * Assert message watch contents to include substring\n   * or match the given regular expression\n   */\n  assertWatchIncludes(substring: string | RegExp) {\n    return this.assertContent('watch', substring)\n  }\n\n  /**\n   * Define one or attachments\n   */\n  attach(\n    file: string | URL,\n    options?: Omit<\n      AttachmentOptions,\n      'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding' | 'encoding'\n    >\n  ): this {\n    const filePath = typeof file === 'string' ? file : fileURLToPath(file)\n\n    this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || []\n    this.nodeMailerMessage.attachments.push({\n      path: filePath,\n      filename: basename(filePath),\n      ...options,\n    })\n    this.#attachmentsForSearch.push({\n      path: filePath,\n      filename: basename(filePath),\n      ...options,\n    })\n\n    return this\n  }\n\n  /**\n   * Check if a file attachment exists by the mentioned\n   * file path or URL.\n   */\n  hasAttachment(file: string | URL, options?: { filename?: string; cid?: string }): boolean\n  hasAttachment(finder: (attachment: Attachment) => boolean): boolean\n  hasAttachment(\n    file: ((attachment: Attachment) => boolean) | string | URL,\n    options?: { filename?: string; cid?: string }\n  ): boolean {\n    const attachments = this.#attachmentsForSearch\n\n    if (typeof file === 'function') {\n      return !!attachments.find(file)\n    }\n\n    const filePath = typeof file === 'string' ? file : fileURLToPath(file)\n    return !!attachments.find((attachment) => {\n      const hasMatchingPath = attachment.path ? String(attachment.path).endsWith(filePath) : false\n      if (!options) {\n        return hasMatchingPath\n      }\n\n      if (options.filename && attachment.filename !== options.filename) {\n        return false\n      }\n\n      if (options.cid && attachment.cid !== options.cid) {\n        return false\n      }\n\n      return true\n    })\n  }\n\n  /**\n   * Assert a file attachment exists by the mentioned\n   * file path or URL.\n   */\n  assertAttachment(file: string | URL, options?: { filename?: string; cid?: string }): void\n  assertAttachment(finder: (attachment: Attachment) => boolean): void\n  assertAttachment(\n    file: ((attachment: Attachment) => boolean) | string | URL,\n    options?: { filename?: string; cid?: string }\n  ): void {\n    if (typeof file === 'function') {\n      if (!this.hasAttachment(file)) {\n        throw new AssertionError({\n          message: `Expected assertion callback to find an attachment`,\n        })\n      }\n      return\n    }\n\n    if (!this.hasAttachment(file, options)) {\n      throw new AssertionError({\n        message: `Expected message attachments to include \"${file}\"`,\n        expected: [{ path: file, ...options }],\n        actual: this.nodeMailerMessage.attachments,\n        operator: 'includes',\n      })\n    }\n  }\n\n  /**\n   * Define attachment from raw data\n   */\n  attachData(\n    content: Readable | Buffer,\n    options: Omit<\n      AttachmentOptions,\n      'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding'\n    > & {\n      filename: string\n    }\n  ): this {\n    this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || []\n    this.nodeMailerMessage.attachments.push({\n      content,\n      ...options,\n    })\n\n    return this\n  }\n\n  /**\n   * Embed attachment inside content using `cid`\n   */\n  embed(\n    file: string | URL,\n    cid: string,\n    options?: Omit<\n      AttachmentOptions,\n      'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding' | 'encoding'\n    >\n  ): this {\n    const filePath = typeof file === 'string' ? file : fileURLToPath(file)\n\n    this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || []\n    this.nodeMailerMessage.attachments.push({\n      path: filePath,\n      cid,\n      filename: basename(filePath),\n      ...options,\n    })\n    this.#attachmentsForSearch.push({\n      path: filePath,\n      cid,\n      filename: basename(filePath),\n      ...options,\n    })\n\n    return this\n  }\n\n  /**\n   * Embed attachment from raw data inside content using `cid`\n   */\n  embedData(\n    content: Readable | Buffer,\n    cid: string,\n    options?: Omit<\n      AttachmentOptions,\n      'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding'\n    >\n  ): this {\n    this.nodeMailerMessage.attachments = this.nodeMailerMessage.attachments || []\n    this.nodeMailerMessage.attachments.push({\n      content,\n      cid,\n      ...options,\n    })\n\n    return this\n  }\n\n  /**\n   * Define custom headers for email\n   */\n  header(key: string, value: string | string[]): this {\n    if (!this.nodeMailerMessage.headers) {\n      this.nodeMailerMessage.headers = {}\n    }\n\n    if (!Array.isArray(this.nodeMailerMessage.headers)) {\n      this.nodeMailerMessage.headers[key] = value\n    }\n\n    return this\n  }\n\n  /**\n   * Check if a header has been defined and optionally\n   * check for values as well.\n   */\n  hasHeader(key: string, value?: string | string[]): boolean {\n    const headers = this.nodeMailerMessage.headers\n    if (!headers || Array.isArray(headers)) {\n      return false\n    }\n\n    const headerValue = headers[key]\n    if (!headerValue) {\n      return false\n    }\n\n    if (value) {\n      return !!(Array.isArray(value) ? value : [value]).every((one) => {\n        return typeof headerValue === 'string'\n          ? headerValue === one\n          : Array.isArray(headerValue)\n            ? headerValue.includes(one)\n            : headerValue.value === one\n      })\n    }\n\n    return true\n  }\n\n  /**\n   * Assert a header has been defined and optionally\n   * check for values as well.\n   */\n  assertHeader(key: string, value?: string | string[]) {\n    if (!this.hasHeader(key, value)) {\n      const headers = this.nodeMailerMessage.headers\n      const actual = headers && !Array.isArray(headers) ? headers[key] : undefined\n\n      if (!value || !actual) {\n        throw new AssertionError({\n          message: `Expected message headers to include \"${key}\"`,\n        })\n      }\n\n      throw new AssertionError({\n        message: `Expected message headers to include \"${key}\" with value \"${value}\"`,\n        actual,\n        expected: value,\n      })\n    }\n  }\n\n  /**\n   * Define custom prepared headers for email\n   */\n  preparedHeader(key: string, value: string): this {\n    if (!this.nodeMailerMessage.headers) {\n      this.nodeMailerMessage.headers = {}\n    }\n\n    if (!Array.isArray(this.nodeMailerMessage.headers)) {\n      this.nodeMailerMessage.headers[key] = { prepared: true, value }\n    }\n\n    return this\n  }\n\n  /**\n   * Defines a `List-` prefix header on the email. Calling\n   * this method multiple times for the same key will\n   * override the old value.\n   */\n  addListHeader(key: string, value: ListHeader | ListHeader[] | ListHeader[][]): this {\n    this.nodeMailerMessage.list = this.nodeMailerMessage.list || {}\n    this.nodeMailerMessage.list[key] = value\n    return this\n  }\n\n  /**\n   * Add `List-Help` header. Calling this method multiple\n   * times will override the existing value\n   */\n  listHelp(value: ListHeader | ListHeader[] | ListHeader[][]) {\n    return this.addListHeader('help', value)\n  }\n\n  /**\n   * Add `List-Unsubscribe` header. Calling this method multiple\n   * times will override the existing value\n   */\n  listUnsubscribe(value: ListHeader | ListHeader[] | ListHeader[][]) {\n    return this.addListHeader('unsubscribe', value)\n  }\n\n  /**\n   * Add `List-Subscribe` header. Calling this method multiple\n   * times will override the existing value\n   */\n  listSubscribe(value: ListHeader | ListHeader[] | ListHeader[][]) {\n    return this.addListHeader('subscribe', value)\n  }\n\n  /**\n   * Attach a calendar event and define contents as string\n   */\n  icalEvent(\n    contents: ((calendar: ICalCalendar) => void) | string,\n    options?: CalendarEventOptions\n  ): this {\n    if (typeof contents === 'function') {\n      const calendar = ical()\n      contents(calendar)\n      contents = calendar.toString()\n    }\n\n    this.nodeMailerMessage.icalEvent = { content: contents, ...options }\n    return this\n  }\n\n  /**\n   * Attach a calendar event and load contents from a file\n   */\n  icalEventFromFile(file: string | URL, options?: CalendarEventOptions): this {\n    const filePath = typeof file === 'string' ? file : fileURLToPath(file)\n    this.nodeMailerMessage.icalEvent = { path: filePath, ...options }\n    return this\n  }\n\n  /**\n   * Attach a calendar event and load contents from a url\n   */\n  icalEventFromUrl(url: string, options?: CalendarEventOptions): this {\n    this.nodeMailerMessage.icalEvent = { href: url, ...options }\n    return this\n  }\n\n  /**\n   * Computes email contents by rendering the configured\n   * templates\n   */\n  async computeContents() {\n    await Message.computeContentsFor({\n      message: this.nodeMailerMessage,\n      views: this.contentViews,\n    })\n  }\n\n  /**\n   * Object representation of the message\n   */\n  toObject(): { message: NodeMailerMessage; views: MessageBodyTemplates } {\n    return {\n      message: this.nodeMailerMessage,\n      views: {\n        ...this.contentViews,\n      },\n    }\n  }\n\n  /**\n   * JSON representation of the message\n   */\n  toJSON(): { message: NodeMailerMessage; views: MessageBodyTemplates } {\n    return this.toObject()\n  }\n}\n","/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Mailer } from './mailer.js'\nimport { Message } from './message.js'\nimport { MailTransportContract, Recipient } from './types.js'\n\n/**\n * Class based emails are self contained dispatchable\n * mail objects\n */\nexport abstract class BaseMail {\n  /**\n   * A flag to avoid build email message for\n   * multiple times\n   */\n  protected built: boolean = false\n\n  /**\n   * Reference to the mail message object\n   */\n  message = new Message()\n\n  /**\n   * Define the email subject\n   */\n  subject?: string\n\n  /**\n   * Define the from address for the email\n   */\n  from?: Recipient\n\n  /**\n   * Define the replyTo email address\n   */\n  replyTo?: Recipient\n\n  /**\n   * Defines the subject on the message using the mail\n   * class subject property\n   */\n  protected defineSubject() {\n    if (this.subject) {\n      this.message.subject(this.subject)\n    }\n  }\n\n  /**\n   * Defines the from on the message using the mail\n   * class from property\n   */\n  protected defineSender() {\n    if (this.from) {\n      typeof this.from === 'string'\n        ? this.message.from(this.from)\n        : this.message.from(this.from.address, this.from.name)\n    }\n\n    if (this.replyTo) {\n      typeof this.replyTo === 'string'\n        ? this.message.replyTo(this.replyTo)\n        : this.message.replyTo(this.replyTo.address, this.replyTo.name)\n    }\n  }\n\n  /**\n   * Prepares the email message\n   */\n  abstract prepare(): void | Promise<void>\n\n  /**\n   * Builds the mail message for sending it\n   */\n  async build(): Promise<void> {\n    if (this.built) {\n      return\n    }\n\n    this.built = true\n    this.defineSubject()\n    this.defineSender()\n    await this.prepare()\n  }\n\n  /**\n   * Builds the mail message with the email contents.\n   * This method will render the templates ahead of\n   * time\n   */\n  async buildWithContents(): Promise<void> {\n    if (this.built) {\n      return\n    }\n\n    await this.build()\n    await this.message.computeContents()\n  }\n\n  /**\n   * Sends the mail\n   */\n  async send<T extends MailTransportContract>(\n    mailer: Mailer<T>,\n    config?: Parameters<T['send']>[1]\n  ): Promise<Awaited<ReturnType<T['send']>>> {\n    await this.build()\n    return mailer.sendCompiled(this.message.toObject(), config)\n  }\n\n  /**\n   * Sends the mail by using the background\n   * messenger\n   */\n  async sendLater<T extends MailTransportContract>(\n    mailer: Mailer<T>,\n    config?: Parameters<T['send']>[1]\n  ) {\n    await this.build()\n    return mailer.sendLaterCompiled(this.message.toObject(), config)\n  }\n}\n","/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { EmitterLike } from '@adonisjs/core/types/events'\n\nimport debug from './debug.js'\nimport { Message } from './message.js'\nimport { BaseMail } from './base_mail.js'\nimport { MemoryQueueMessenger } from './messengers/memory_queue.js'\nimport type {\n  MailEvents,\n  MailerConfig,\n  MailerContract,\n  MailerMessenger,\n  NodeMailerMessage,\n  MailTransportContract,\n  MessageBodyTemplates,\n  MessageComposeCallback,\n} from './types.js'\n\n/**\n * The Mailer acts as an adapter that wraps a transport and exposes\n * consistent API for sending and queueing emails\n */\nexport class Mailer<Transport extends MailTransportContract> implements MailerContract<Transport> {\n  /**\n   * Reference to AdonisJS application emitter\n   */\n  #emitter: EmitterLike<MailEvents>\n\n  /**\n   * Messenger to use for queuing emails\n   */\n  #messenger: MailerMessenger\n\n  constructor(\n    public name: string,\n    public transport: Transport,\n    emitter: EmitterLike<MailEvents>,\n    public config: MailerConfig = {}\n  ) {\n    this.#emitter = emitter\n    this.#messenger = new MemoryQueueMessenger(this, this.#emitter)\n  }\n\n  /**\n   * Configure the messenger to use for sending email asynchronously\n   */\n  setMessenger(messenger: MailerMessenger): this {\n    this.#messenger = messenger\n    return this\n  }\n\n  /**\n   * Sends a compiled email using the underlying transport\n   */\n  async sendCompiled(\n    mail: { message: NodeMailerMessage; views: MessageBodyTemplates },\n    sendConfig?: unknown\n  ): Promise<Awaited<ReturnType<Transport['send']>>> {\n    /**\n     * Use the global from address when no from address\n     * is defined on the mail\n     */\n    if (!mail.message.from && this.config.from) {\n      mail.message.from = this.config.from\n    }\n\n    /**\n     * Use the global from address when no from address\n     * is defined on the mail\n     */\n    if (!mail.message.replyTo && this.config.replyTo) {\n      mail.message.replyTo = [this.config.replyTo]\n    }\n\n    /**\n     * Notify, about to send the email\n     */\n    this.#emitter.emit('mail:sending', {\n      ...mail,\n      mailerName: this.name,\n    })\n\n    /**\n     * Mutates the \"compiledMessage.message\" object based upon\n     * the configured templates\n     */\n    await Message.computeContentsFor(mail)\n\n    /**\n     * Send the message using the transport\n     */\n    debug('sending email, subject \"%s\"', mail.message.subject)\n    const response = await this.transport.send(mail.message, sendConfig)\n    debug('email sent, message id \"%s\"', response.messageId)\n\n    /**\n     * Notify, email has been sent\n     */\n    this.#emitter.emit('mail:sent', {\n      ...mail,\n      mailerName: this.name,\n      response,\n    })\n\n    return response as Awaited<ReturnType<Transport['send']>>\n  }\n\n  /**\n   * Queues a compiled email\n   */\n  async sendLaterCompiled(\n    compiledMessage: { message: NodeMailerMessage; views: MessageBodyTemplates },\n    sendConfig?: unknown\n  ) {\n    /**\n     * Notify, we are queueing the email\n     */\n    this.#emitter.emit('mail:queueing', {\n      ...compiledMessage,\n      mailerName: this.name,\n    })\n\n    /**\n     * Queuing email\n     */\n    debug('queueing email')\n    const metaData = await this.#messenger.queue(compiledMessage, sendConfig)\n\n    /**\n     * Notify, the email has been queued\n     */\n    this.#emitter.emit('mail:queued', {\n      ...compiledMessage,\n      metaData,\n      mailerName: this.name,\n    })\n  }\n\n  /**\n   * Sends email\n   */\n  async send(\n    callbackOrMail: MessageComposeCallback | BaseMail,\n    config?: Parameters<Transport['send']>[1]\n  ): Promise<Awaited<ReturnType<Transport['send']>>> {\n    if (callbackOrMail instanceof BaseMail) {\n      return callbackOrMail.send(this, config)\n    }\n\n    const message = new Message()\n\n    /**\n     * Set the default from address, the user can override it\n     * inside the callback\n     */\n    if (this.config.from) {\n      typeof this.config.from === 'string'\n        ? message.from(this.config.from)\n        : message.from(this.config.from.address, this.config.from.name)\n    }\n\n    /**\n     * Invoke callback to configure the mail message\n     */\n    await callbackOrMail(message)\n\n    /**\n     * Compile the message to an object\n     */\n    const compiledMessage = message.toObject()\n    return this.sendCompiled(compiledMessage, config)\n  }\n\n  /**\n   * Send an email asynchronously using the mail messenger. The\n   * default messenger uses an in-memory queue, unless you have\n   * configured a custom messenger.\n   */\n  async sendLater(\n    callbackOrMail: MessageComposeCallback | BaseMail,\n    config?: Parameters<Transport['send']>[1]\n  ): Promise<void> {\n    if (callbackOrMail instanceof BaseMail) {\n      return callbackOrMail.sendLater(this, config)\n    }\n\n    const message = new Message()\n\n    /**\n     * Invoke callback to configure the mail message\n     */\n    await callbackOrMail(message)\n\n    /**\n     * Compile the message to an object\n     */\n    const compiledMessage = message.toObject()\n    return this.sendLaterCompiled(compiledMessage, config)\n  }\n\n  /**\n   * Invokes `close` method on the transport\n   */\n  async close() {\n    await this.transport.close?.()\n  }\n}\n","/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport string from '@poppinss/utils/string'\nimport type Configure from '@adonisjs/core/commands/configure'\n\nimport { stubsRoot } from './stubs/main.js'\n\n/**\n * List of env variables used by different transports\n */\nconst ENV_VARIABLES = {\n  smtp: ['SMTP_HOST', 'SMTP_PORT'],\n  ses: ['AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_REGION'],\n  mailgun: ['MAILGUN_API_KEY', 'MAILGUN_DOMAIN'],\n  sparkpost: ['SPARKPOST_API_KEY'],\n  resend: ['RESEND_API_KEY'],\n  brevo: ['BREVO_API_KEY'],\n}\n\n/**\n * List of supported transports\n */\nconst KNOWN_TRANSPORTS = Object.keys(ENV_VARIABLES)\n\n/**\n * Configures the package\n */\nexport async function configure(command: Configure) {\n  /**\n   * Read transports from the \"--transports\" CLI flag\n   */\n  let selectedTransports: string | string[] | undefined = command.parsedFlags.transports\n\n  /**\n   * Display prompts when transports have been selected\n   * via the CLI flag\n   */\n  if (!selectedTransports) {\n    selectedTransports = await command.prompt.multiple(\n      'Select the mail services you want to use',\n      KNOWN_TRANSPORTS,\n      {\n        validate(values) {\n          return !values || !values.length ? 'Please select one or more transports' : true\n        },\n      }\n    )\n  }\n\n  /**\n   * Normalized list of transports\n   */\n  const transports =\n    typeof selectedTransports === 'string' ? [selectedTransports] : selectedTransports!\n\n  const unknownTransport = transports.find((transport) => !KNOWN_TRANSPORTS.includes(transport))\n  if (unknownTransport) {\n    command.exitCode = 1\n    command.logger.logError(\n      `Invalid transport \"${unknownTransport}\". Supported transports are: ${string.sentence(\n        KNOWN_TRANSPORTS\n      )}`\n    )\n    return\n  }\n\n  const codemods = await command.createCodemods()\n\n  /**\n   * Publish config file\n   */\n  await codemods.makeUsingStub(stubsRoot, 'config/mail.stub', {\n    transports: transports,\n  })\n\n  /**\n   * Publish provider and command\n   */\n  await codemods.updateRcFile((rcFile) => {\n    rcFile.addProvider('@adonisjs/mail/mail_provider')\n    rcFile.addCommand('@adonisjs/mail/commands')\n  })\n\n  /**\n   * Define env variables for the selected transports\n   */\n  await codemods.defineEnvVariables(\n    transports.reduce<Record<string, string>>((result, transport) => {\n      ENV_VARIABLES[transport as keyof typeof ENV_VARIABLES].forEach((envVariable) => {\n        result[envVariable] = ''\n      })\n      return result\n    }, {})\n  )\n\n  /**\n   * Define env variables validation for the selected transports\n   */\n  await codemods.defineEnvValidations({\n    leadingComment: 'Variables for configuring the mail package',\n    variables: transports.reduce<Record<string, string>>((result, transport) => {\n      ENV_VARIABLES[transport as keyof typeof ENV_VARIABLES].forEach((envVariable) => {\n        result[envVariable] = 'Env.schema.string()'\n      })\n      return result\n    }, {}),\n  })\n}\n","/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport string from '@poppinss/utils/string'\nimport { AssertionError } from 'node:assert'\nimport type { EmitterLike } from '@adonisjs/core/types/events'\nimport type { SentMessageInfo } from 'nodemailer/lib/json-transport/index.js'\n\nimport { Mailer } from './mailer.js'\nimport type { Message } from './message.js'\nimport { BaseMail } from './base_mail.js'\nimport type { MailResponse } from './mail_response.js'\nimport { JSONTransport } from './transports/json.js'\nimport type {\n  MailEvents,\n  MailerConfig,\n  MailerContract,\n  MailerMessenger,\n  MessageSearchOptions,\n  NormalizeConstructor,\n  MessageComposeCallback,\n} from './types.js'\n\n/**\n * Mails collection to collect mails sent or queued during\n * the fake mode\n */\nclass MailsCollection {\n  #sent: BaseMail[] = []\n  #queued: BaseMail[] = []\n\n  trackSent(mail: BaseMail) {\n    this.#sent.push(mail)\n  }\n  trackQueued(mail: BaseMail) {\n    this.#queued.push(mail)\n  }\n  clear() {\n    this.#sent = []\n    this.#queued = []\n  }\n\n  /**\n   * Returns a list of sent emails captured by the fake mailer\n   */\n  sent(filterFn?: (mail: BaseMail) => boolean) {\n    return filterFn ? this.#sent.filter(filterFn) : this.#sent\n  }\n\n  /**\n   * Returns a list of queued emails captured by the fake mailer\n   */\n  queued(filterFn?: (mail: BaseMail) => boolean) {\n    return filterFn ? this.#queued.filter(filterFn) : this.#queued\n  }\n\n  /**\n   * Assert the mentioned mail was sent during the fake\n   * mode\n   */\n  assertSent<T extends NormalizeConstructor<typeof BaseMail>>(\n    mailConstructor: T,\n    findFn?: (mail: InstanceType<T>) => boolean\n  ) {\n    const matchingMail = this.#sent.find((mail) => {\n      if (!findFn) {\n        return mail instanceof mailConstructor\n      }\n      return mail instanceof mailConstructor && findFn(mail as InstanceType<T>)\n    })\n\n    if (!matchingMail) {\n      throw new AssertionError({\n        message: `Expected mail \"${mailConstructor.name}\" was not sent`,\n      })\n    }\n  }\n\n  /**\n   * Assert the mentioned mail was NOT sent during the fake\n   * mode\n   */\n  assertNotSent<T extends NormalizeConstructor<typeof BaseMail>>(\n    mailConstructor: T,\n    findFn?: (mail: InstanceType<T>) => boolean\n  ) {\n    const matchingMail = this.#sent.find((mail) => {\n      if (!findFn) {\n        return mail instanceof mailConstructor\n      }\n      return mail instanceof mailConstructor && findFn(mail as InstanceType<T>)\n    })\n\n    if (matchingMail) {\n      throw new AssertionError({\n        message: `Unexpected mail \"${mailConstructor.name}\" was sent`,\n      })\n    }\n  }\n\n  /**\n   * Assert a total of expected number of mails were sent\n   */\n  assertSentCount(count: number): void\n\n  /**\n   * Assert the mentioned mail was sent for expected number\n   * of times\n   */\n  assertSentCount(mailConstructor: NormalizeConstructor<typeof BaseMail>, count: number): void\n  assertSentCount(\n    mailConstructor: NormalizeConstructor<typeof BaseMail> | number,\n    count?: number\n  ): void {\n    if (typeof mailConstructor === 'number') {\n      const actual = this.#sent.length\n      const expected = mailConstructor\n      if (actual !== expected) {\n        throw new AssertionError({\n          message: `Expected to send \"${expected}\" ${string.pluralize(\n            'mail',\n            expected\n          )}, instead received \"${actual}\" ${string.pluralize('mail', actual)}`,\n          actual,\n          expected,\n        })\n      }\n      return\n    }\n\n    const actual = this.sent((mail) => mail instanceof mailConstructor).length\n    const expected = count as number\n    if (actual !== expected) {\n      throw new AssertionError({\n        message: `Expected \"${mailConstructor.name}\" to be sent \"${expected}\" ${string.pluralize(\n          'time',\n          expected\n        )}, instead it was sent \"${actual}\" ${string.pluralize('time', actual)}`,\n        actual,\n        expected,\n      })\n    }\n  }\n\n  /**\n   * Assert zero emails were sent\n   */\n  assertNoneSent() {\n    if (this.#sent.length) {\n      throw new AssertionError({\n        message: `Expected zero mail to be sent, instead received \"${this.#sent.length}\" mail`,\n        expected: [],\n        actual: [this.#sent.map((mail) => mail.constructor.name)],\n      })\n    }\n  }\n\n  /**\n   * Assert the mentioned mail was queued during the fake\n   * mode\n   */\n  assertQueued<T extends NormalizeConstructor<typeof BaseMail>>(\n    mailConstructor: T,\n    findFn?: (mail: InstanceType<T>) => boolean\n  ) {\n    const matchingMail = this.#queued.find((mail) => {\n      if (!findFn) {\n        return mail instanceof mailConstructor\n      }\n      return mail instanceof mailConstructor && findFn(mail as InstanceType<T>)\n    })\n\n    if (!matchingMail) {\n      throw new AssertionError({\n        message: `Expected mail \"${mailConstructor.name}\" was not queued`,\n      })\n    }\n  }\n\n  /**\n   * Assert the mentioned mail was NOT queued during the fake\n   * mode\n   */\n  assertNotQueued<T extends NormalizeConstructor<typeof BaseMail>>(\n    mailConstructor: T,\n    findFn?: (mail: InstanceType<T>) => boolean\n  ) {\n    const matchingMail = this.#queued.find((mail) => {\n      if (!findFn) {\n        return mail instanceof mailConstructor\n      }\n      return mail instanceof mailConstructor && findFn(mail as InstanceType<T>)\n    })\n\n    if (matchingMail) {\n      throw new AssertionError({\n        message: `Unexpected mail \"${mailConstructor.name}\" was queued`,\n      })\n    }\n  }\n\n  /**\n   * Assert a total of expected number of mails were queued\n   */\n  assertQueuedCount(count: number): void\n\n  /**\n   * Assert the mentioned mail was sequeuednt for expected number\n   * of times\n   */\n  assertQueuedCount(mailConstructor: NormalizeConstructor<typeof BaseMail>, count: number): void\n  assertQueuedCount(\n    mailConstructor: NormalizeConstructor<typeof BaseMail> | number,\n    count?: number\n  ): void {\n    if (typeof mailConstructor === 'number') {\n      const actual = this.#queued.length\n      const expected = mailConstructor\n      if (actual !== expected) {\n        throw new AssertionError({\n          message: `Expected to queue \"${expected}\" ${string.pluralize(\n            'mail',\n            expected\n          )}, instead received \"${actual}\" ${string.pluralize('mail', actual)}`,\n          actual,\n          expected,\n        })\n      }\n      return\n    }\n\n    const actual = this.queued((mail) => mail instanceof mailConstructor).length\n    const expected = count as number\n    if (actual !== expected) {\n      throw new AssertionError({\n        message: `Expected \"${mailConstructor.name}\" to be queued \"${expected}\" ${string.pluralize(\n          'time',\n          expected\n        )}, instead it was queued \"${actual}\" ${string.pluralize('time', actual)}`,\n        actual,\n        expected,\n      })\n    }\n  }\n\n  /**\n   * Assert zero emails were queued\n   */\n  assertNoneQueued() {\n    if (this.#queued.length) {\n      throw new AssertionError({\n        message: `Expected zero mail to be queued, instead received \"${this.#queued.length}\" mail`,\n        expected: [],\n        actual: [this.#queued.map((mail) => mail.constructor.name)],\n      })\n    }\n  }\n}\n\n/**\n * Messages collection to collect messages sent or queued during\n * the fake mode\n */\nclass MessagesCollection {\n  #sent: Message[] = []\n  #queued: Message[] = []\n\n  /**\n   * Default finder to find a message using search options\n   */\n  #messageFinder = (message: Message, searchOptions: MessageSearchOptions): boolean => {\n    if (searchOptions.from && !message.hasFrom(searchOptions.from)) {\n      return false\n    }\n    if (searchOptions.to && !message.hasTo(searchOptions.to)) {\n      return false\n    }\n    if (searchOptions.subject && !message.hasSubject(searchOptions.subject)) {\n      return false\n    }\n    if (\n      searchOptions.attachments &&\n      !searchOptions.attachments.every((attachment) => message.hasAttachment(attachment))\n    ) {\n      return false\n    }\n    return true\n  }\n\n  trackSent(message: Message) {\n    this.#sent.push(message)\n  }\n  trackQueued(message: Message) {\n    this.#queued.push(message)\n  }\n  clear() {\n    this.#sent = []\n    this.#queued = []\n  }\n\n  /**\n   * Returns a list of sent messages captured by the fake mailer\n   */\n  sent(filterFn?: (message: Message) => boolean) {\n    return filterFn ? this.#sent.filter(filterFn) : this.#sent\n  }\n\n  /**\n   * Returns a list of queued messages captured by the fake mailer\n   */\n  queued(filterFn?: (message: Message) => boolean) {\n    return filterFn ? this.#queued.filter(filterFn) : this.#queued\n  }\n\n  /**\n   * Assert the mentioned message was sent during the fake\n   * mode\n   */\n  assertSent(finder: ((message: Message) => boolean) | MessageSearchOptions) {\n    const matchingMessage = this.#sent.find(\n      typeof finder === 'function' ? finder : (message) => this.#messageFinder(message, finder)\n    )\n\n    if (!matchingMessage) {\n      throw new AssertionError({\n        message: `Expected message was not sent`,\n      })\n    }\n  }\n\n  /**\n   * Assert the mentioned message was NOT sent during the fake\n   * mode\n   */\n  assertNotSent(finder: ((message: Message) => boolean) | MessageSearchOptions) {\n    const matchingMessage = this.#sent.find(\n      typeof finder === 'function' ? finder : (message) => this.#messageFinder(message, finder)\n    )\n\n    if (matchingMessage) {\n      throw new AssertionError({\n        message: `Unexpected message was sent`,\n      })\n    }\n  }\n\n  /**\n   * Assert a total of expected number of messages were sent\n   */\n  assertSentCount(count: number): void\n\n  /**\n   * Assert the mentioned message was sent for expected number\n   * of times\n   */\n  assertSentCount(\n    finder: ((message: Message) => boolean) | MessageSearchOptions,\n    count: number\n  ): void\n  assertSentCount(\n    finder: ((message: Message) => boolean) | MessageSearchOptions | number,\n    count?: number\n  ): void {\n    if (typeof finder === 'number') {\n      const actual = this.#sent.length\n      const expected = finder\n      if (actual !== expected) {\n        throw new AssertionError({\n          message: `Expected to send \"${expected}\" ${string.pluralize(\n            'message',\n            expected\n          )}, instead received \"${actual}\" ${string.pluralize('message', actual)}`,\n          actual,\n          expected,\n        })\n      }\n      return\n    }\n\n    const actual = this.sent(\n      typeof finder === 'function' ? finder : (message) => this.#messageFinder(message, finder)\n    ).length\n    const expected = count as number\n\n    if (actual !== expected) {\n      throw new AssertionError({\n        message: `Expected to send \"${expected}\" ${string.pluralize(\n          'message',\n          expected\n        )}, instead received \"${actual}\" ${string.pluralize('message', actual)}`,\n        actual,\n        expected,\n      })\n    }\n  }\n\n  /**\n   * Assert zero messages were sent\n   */\n  assertNoneSent() {\n    if (this.#sent.length) {\n      throw new AssertionError({\n        message: `Expected zero messages to be sent, instead received \"${\n          this.#sent.length\n        }\" ${string.pluralize('message', this.#sent.length)}`,\n      })\n    }\n  }\n\n  /**\n   * Assert the mentioned message was queued during the fake\n   * mode\n   */\n  assertQueued(finder: ((message: Message) => boolean) | MessageSearchOptions) {\n    const matchingMessage = this.#queued.find(\n      typeof finder === 'function' ? finder : (message) => this.#messageFinder(message, finder)\n    )\n\n    if (!matchingMessage) {\n      throw new AssertionError({\n        message: `Expected message was not queued`,\n      })\n    }\n  }\n\n  /**\n   * Assert the mentioned message was NOT queued during the fake\n   * mode\n   */\n  assertNotQueued(finder: ((message: Message) => boolean) | MessageSearchOptions) {\n    const matchingMessage = this.#queued.find(\n      typeof finder === 'function' ? finder : (message) => this.#messageFinder(message, finder)\n    )\n\n    if (matchingMessage) {\n      throw new AssertionError({\n        message: `Unexpected message was queued`,\n      })\n    }\n  }\n\n  /**\n   * Assert a total of expected number of messages were queued\n   */\n  assertQueuedCount(count: number): void\n\n  /**\n   * Assert the mentioned message was queued for expected number\n   * of times\n   */\n  assertQueuedCount(\n    finder: ((message: Message) => boolean) | MessageSearchOptions,\n    count: number\n  ): void\n  assertQueuedCount(\n    finder: ((message: Message) => boolean) | MessageSearchOptions | number,\n    count?: number\n  ): void {\n    if (typeof finder === 'number') {\n      const actual = this.#queued.length\n      const expected = finder\n      if (actual !== expected) {\n        throw new AssertionError({\n          message: `Expected to queue \"${expected}\" ${string.pluralize(\n            'message',\n            expected\n          )}, instead received \"${actual}\" ${string.pluralize('message', actual)}`,\n          actual,\n          expected,\n        })\n      }\n      return\n    }\n\n    const actual = this.queued(\n      typeof finder === 'function' ? finder : (message) => this.#messageFinder(message, finder)\n    ).length\n    const expected = count as number\n\n    if (actual !== expected) {\n      throw new AssertionError({\n        message: `Expected to queue \"${expected}\" ${string.pluralize(\n          'message',\n          expected\n        )}, instead received \"${actual}\" ${string.pluralize('message', actual)}`,\n        actual,\n        expected,\n      })\n    }\n  }\n\n  /**\n   * Assert zero messages were queued\n   */\n  assertNoneQueued() {\n    if (this.#queued.length) {\n      throw new AssertionError({\n        message: `Expected zero messages to be queued, instead received \"${\n          this.#queued.length\n        }\" ${string.pluralize('message', this.#queued.length)}`,\n      })\n    }\n  }\n}\n\n/**\n * Fake mailer uses the JSON transport to send emails and\n * collects them within memory for a better testing\n * experience.\n */\nexport class FakeMailer extends Mailer<JSONTransport> implements MailerContract<JSONTransport> {\n  mails = new MailsCollection()\n  messages = new MessagesCollection()\n\n  constructor(name: string, emitter: EmitterLike<MailEvents>, config: MailerConfig) {\n    super(name, new JSONTransport(), emitter, config)\n    super.setMessenger({\n      queue: async (mail, sendConfig) => {\n        return this.sendCompiled(mail, sendConfig)\n      },\n    })\n  }\n\n  /**\n   * Define the messenger to use for queueing emails.\n   * The fake mailer ignores using a custom messenger\n   */\n  setMessenger(_: MailerMessenger): this {\n    return this\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async send(\n    callbackOrMail: MessageComposeCallback | BaseMail,\n    config?: undefined\n  ): Promise<MailResponse<SentMessageInfo>> {\n    if (callbackOrMail instanceof BaseMail) {\n      this.mails.trackSent(callbackOrMail)\n      const response = await super.send(callbackOrMail, config)\n      return response\n    }\n\n    const response = await super.send((message) => {\n      callbackOrMail(message)\n      this.messages.trackSent(message)\n    }, config)\n\n    return response\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async sendLater(\n    callbackOrMail: MessageComposeCallback | BaseMail,\n    config?: undefined\n  ): Promise<void> {\n    if (callbackOrMail instanceof BaseMail) {\n      this.mails.trackQueued(callbackOrMail)\n      await callbackOrMail.sendLater(this, config)\n      return\n    }\n\n    await super.sendLater((message) => {\n      callbackOrMail(message)\n      this.messages.trackQueued(message)\n    }, config)\n  }\n\n  async close() {\n    this.messages.clear()\n    this.mails.clear()\n    super.close()\n  }\n}\n","/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { RuntimeException } from '@poppinss/utils'\nimport type { EmitterLike } from '@adonisjs/core/types/events'\n\nimport debug from './debug.js'\nimport { Mailer } from './mailer.js'\nimport { FakeMailer } from './fake_mailer.js'\nimport type { BaseMail } from './base_mail.js'\nimport type {\n  MailEvents,\n  MailerConfig,\n  MailerMessenger,\n  MailTransportContract,\n  MessageComposeCallback,\n  MailManagerTransportFactory,\n} from './types.js'\n\n/**\n * Mail manager exposes the API to configure multiple mailers, manage\n * their lifecycle and switch between them.\n */\nexport class MailManager<KnownMailers extends Record<string, MailManagerTransportFactory>> {\n  #emitter: EmitterLike<MailEvents>\n\n  /**\n   * Messenger to use on all mailers created\n   * using the mail manager\n   */\n  #messenger?: (mailer: Mailer<MailTransportContract>) => MailerMessenger\n\n  /**\n   * Reference to the fake mailer (if any)\n   */\n  #fakeMailer?: FakeMailer\n\n  /**\n   * Cache of mailers\n   */\n  #mailersCache: Partial<Record<keyof KnownMailers, Mailer<MailTransportContract>>> = {}\n\n  constructor(\n    emitter: EmitterLike<MailEvents>,\n    public config: MailerConfig & {\n      default?: keyof KnownMailers\n      mailers: KnownMailers\n    }\n  ) {\n    debug('creating mail manager %O', config)\n    this.#emitter = emitter\n  }\n\n  /**\n   * Configure the messenger for all the mailers managed\n   * by the mail manager class.\n   */\n  setMessenger(messenger: (mailer: Mailer<MailTransportContract>) => MailerMessenger): this {\n    this.#messenger = messenger\n    Object.keys(this.#mailersCache).forEach((name) => {\n      const mailer = this.#mailersCache[name]!\n      mailer.setMessenger(messenger(mailer))\n    })\n    return this\n  }\n\n  /**\n   * Send email using the default mailer\n   */\n  send(callbackOrMail: MessageComposeCallback | BaseMail, config?: unknown) {\n    return this.use().send(callbackOrMail, config)\n  }\n\n  /**\n   * Queue email using the default mailer\n   */\n  async sendLater(callbackOrMail: MessageComposeCallback | BaseMail, config?: unknown) {\n    await this.use().sendLater(callbackOrMail, config)\n  }\n\n  /**\n   * Create/use an instance of a known mailer. The mailer\n   * instances are cached for the lifecycle of the process\n   */\n  use<K extends keyof KnownMailers>(mailerName?: K): Mailer<ReturnType<KnownMailers[K]>> {\n    let mailerToUse: keyof KnownMailers | undefined = mailerName || this.config.default\n\n    if (!mailerToUse) {\n      throw new RuntimeException(\n        'Cannot create mailer instance. No default mailer is defined in the config'\n      )\n    }\n    if (!this.config.mailers[mailerToUse]) {\n      throw new RuntimeException(\n        `Unknow mailer \"${String(mailerToUse)}\". Make sure it is configured inside the config file`\n      )\n    }\n\n    /**\n     * Return fake mailer if one exists\n     */\n    if (this.#fakeMailer) {\n      return this.#fakeMailer as unknown as Mailer<ReturnType<KnownMailers[K]>>\n    }\n\n    /**\n     * Use cached copy if exists\n     */\n    const cachedMailer = this.#mailersCache[mailerToUse]\n    if (cachedMailer) {\n      debug('using mailer from cache. name: \"%s\"', cachedMailer)\n      return cachedMailer as Mailer<ReturnType<KnownMailers[K]>>\n    }\n\n    /**\n     * Create transport instance using the factory\n     */\n    const transportFactory = this.config.mailers[mailerToUse]\n\n    /**\n     * Create mailer instance with the transport\n     */\n    debug('creating mailer transport. name: \"%s\"', mailerToUse)\n    const mailer = new Mailer(mailerToUse as string, transportFactory(), this.#emitter, this.config)\n    if (this.#messenger) {\n      mailer.setMessenger(this.#messenger(mailer))\n    }\n\n    /**\n     * Cache it\n     */\n    this.#mailersCache[mailerToUse] = mailer\n\n    return mailer as Mailer<ReturnType<KnownMailers[K]>>\n  }\n\n  /**\n   * Turn on fake mode. After this all calls to \"mail.use\" will\n   * return an instance of the fake mailer\n   */\n  fake(): FakeMailer {\n    this.restore()\n\n    debug('creating fake mailer')\n    this.#fakeMailer = new FakeMailer('fake', this.#emitter, this.config)\n    return this.#fakeMailer\n  }\n\n  /**\n   * Turn off fake mode and restore normal behavior\n   */\n  restore() {\n    if (this.#fakeMailer) {\n      this.#fakeMailer.close()\n      this.#fakeMailer = undefined\n      debug('restoring mailer fake')\n    }\n  }\n\n  /**\n   * Clear mailer from cache and close its transport\n   */\n  async close<K extends keyof KnownMailers>(mailerName: K) {\n    const mailer = this.#mailersCache[mailerName]!\n    if (mailer) {\n      debug('closing mailer %s', mailerName)\n      await mailer.close()\n      delete this.#mailersCache[mailerName]\n    }\n  }\n\n  /**\n   * Clear all mailers from cache and close their transports\n   */\n  async closeAll() {\n    await Promise.all(Object.keys(this.#mailersCache).map((mailerName) => this.close(mailerName)))\n  }\n}\n","/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { configProvider } from '@adonisjs/core'\nimport type { ConfigProvider } from '@adonisjs/core/types'\n\nimport type { SESTransport } from './transports/ses.js'\nimport type { SMTPTransport } from './transports/smtp.js'\nimport type { BrevoTransport } from './transports/brevo.js'\nimport type { ResendTransport } from './transports/resend.js'\nimport type { MailgunTransport } from './transports/mailgun.js'\nimport type { SparkPostTransport } from './transports/sparkpost.js'\nimport type {\n  SESConfig,\n  SMTPConfig,\n  BrevoConfig,\n  MailerConfig,\n  ResendConfig,\n  MailgunConfig,\n  SparkPostConfig,\n  MailManagerTransportFactory,\n} from './types.js'\n\n/**\n * Helper to remap known mailers to factory functions\n */\ntype ResolvedConfig<KnownMailers extends Record<string, MailManagerTransportFactory>> =\n  MailerConfig & {\n    default?: keyof KnownMailers\n    mailers: {\n      [K in keyof KnownMailers]: KnownMailers[K] extends ConfigProvider<infer A>\n        ? A\n        : KnownMailers[K]\n    }\n  }\n\n/**\n * Helper function to define config for the mail\n * service\n */\nexport function defineConfig<KnownMailers extends Record<string, MailManagerTransportFactory>>(\n  config: MailerConfig & {\n    default?: keyof KnownMailers\n    mailers: {\n      [K in keyof KnownMailers]: ConfigProvider<KnownMailers[K]> | KnownMailers[K]\n    }\n  }\n): ConfigProvider<ResolvedConfig<KnownMailers>> {\n  return configProvider.create(async (app) => {\n    const { mailers, default: defaultMailer, ...rest } = config\n    const mailersNames = Object.keys(mailers)\n    const transports = {} as Record<string, MailManagerTransportFactory>\n\n    for (let mailerName of mailersNames) {\n      const mailerTransport = mailers[mailerName]\n      if (typeof mailerTransport === 'function') {\n        transports[mailerName] = mailerTransport\n      } else {\n        transports[mailerName] = await mailerTransport.resolver(app)\n      }\n    }\n\n    return {\n      default: defaultMailer,\n      mailers: transports,\n      ...rest,\n    } as ResolvedConfig<KnownMailers>\n  })\n}\n\n/**\n * Config helpers to create a reference for inbuilt\n * mail transports\n */\nexport const transports: {\n  smtp: (config: SMTPConfig) => ConfigProvider<() => SMTPTransport>\n  ses: (config: SESConfig) => ConfigProvider<() => SESTransport>\n  mailgun: (config: MailgunConfig) => ConfigProvider<() => MailgunTransport>\n  sparkpost: (config: SparkPostConfig) => ConfigProvider<() => SparkPostTransport>\n  resend: (config: ResendConfig) => ConfigProvider<() => ResendTransport>\n  brevo: (config: BrevoConfig) => ConfigProvider<() => BrevoTransport>\n} = {\n  smtp(config) {\n    return configProvider.create(async () => {\n      const { SMTPTransport } = await import('./transports/smtp.js')\n      return () => new SMTPTransport(config)\n    })\n  },\n  ses(config) {\n    return configProvider.create(async () => {\n      const { SESTransport } = await import('./transports/ses.js')\n      return () => new SESTransport(config)\n    })\n  },\n  mailgun(config) {\n    return configProvider.create(async () => {\n      const { MailgunTransport } = await import('./transports/mailgun.js')\n      return () => new MailgunTransport(config)\n    })\n  },\n  sparkpost(config) {\n    return configProvider.create(async () => {\n      const { SparkPostTransport } = await import('./transports/sparkpost.js')\n      return () => new SparkPostTransport(config)\n    })\n  },\n  resend(config) {\n    return configProvider.create(async () => {\n      const { ResendTransport } = await import('./transports/resend.js')\n      return () => new ResendTransport(config)\n    })\n  },\n  brevo(config) {\n    return configProvider.create(async () => {\n      const { BrevoTransport } = await import('./transports/brevo.js')\n      return () => new BrevoTransport(config)\n    })\n  },\n}\n"],"mappings":"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","names":["basename","fileURLToPath","Macroable","AssertionError","cuid","RuntimeException","ical","Message","Macroable","templateEngine","computeContentsFor","message","views","getTemplateEngine","RuntimeException","viewHelpers","embedImage","filePath","options","cid","cuid","attachments","push","path","filename","basename","embedImageData","data","content","html","debug","render","template","text","watch","contentViews","nodeMailerMessage","formatRecipient","recipient","undefined","name","address","hasRecipient","property","recipients","find","assertRecipient","expected","actual","map","AssertionError","operator","to","hasTo","assertTo","from","hasFrom","fromAddress","assertFrom","cc","addresses","forEach","hasCc","assertCc","bcc","hasBcc","assertBcc","messageId","subject","hasSubject","assertSubject","replyTo","hasReplyTo","assertReplyTo","inReplyTo","references","messagesIds","envelope","encoding","priority","htmlView","textView","watchView","assertContent","substring","contents","String","includes","test","assertTextIncludes","assertHtmlIncludes","assertWatchIncludes","attach","file","fileURLToPath","hasAttachment","attachment","hasMatchingPath","endsWith","assertAttachment","attachData","embed","embedData","header","key","value","headers","Array","isArray","hasHeader","headerValue","every","one","assertHeader","preparedHeader","prepared","addListHeader","list","listHelp","listUnsubscribe","listSubscribe","icalEvent","calendar","ical","toString","icalEventFromFile","icalEventFromUrl","url","href","computeContents","toObject","toJSON","BaseMail","built","message","Message","subject","from","replyTo","defineSubject","defineSender","address","name","build","prepare","buildWithContents","computeContents","send","mailer","config","sendCompiled","toObject","sendLater","sendLaterCompiled","Mailer","constructor","name","transport","emitter","config","MemoryQueueMessenger","setMessenger","messenger","sendCompiled","mail","sendConfig","message","from","replyTo","emit","mailerName","Message","computeContentsFor","debug","subject","response","send","messageId","sendLaterCompiled","compiledMessage","metaData","queue","callbackOrMail","BaseMail","address","toObject","sendLater","close","string","ENV_VARIABLES","smtp","ses","mailgun","sparkpost","resend","brevo","KNOWN_TRANSPORTS","Object","keys","configure","command","selectedTransports","parsedFlags","transports","prompt","multiple","validate","values","length","unknownTransport","find","transport","includes","exitCode","logger","logError","string","sentence","codemods","createCodemods","makeUsingStub","stubsRoot","updateRcFile","rcFile","addProvider","addCommand","defineEnvVariables","reduce","result","forEach","envVariable","defineEnvValidations","leadingComment","variables","string","AssertionError","MailsCollection","trackSent","mail","push","trackQueued","clear","sent","filterFn","filter","queued","assertSent","mailConstructor","findFn","matchingMail","find","AssertionError","message","name","assertNotSent","assertSentCount","count","actual","length","expected","string","pluralize","assertNoneSent","map","constructor","assertQueued","assertNotQueued","assertQueuedCount","assertNoneQueued","MessagesCollection","searchOptions","from","hasFrom","to","hasTo","subject","hasSubject","attachments","every","attachment","hasAttachment","finder","matchingMessage","FakeMailer","Mailer","mails","messages","emitter","config","JSONTransport","setMessenger","queue","sendConfig","sendCompiled","_","send","callbackOrMail","BaseMail","response","sendLater","close","RuntimeException","MailManager","constructor","emitter","config","debug","setMessenger","messenger","Object","keys","forEach","name","mailer","send","callbackOrMail","use","sendLater","mailerName","mailerToUse","default","RuntimeException","mailers","String","cachedMailer","transportFactory","Mailer","fake","restore","FakeMailer","close","undefined","closeAll","Promise","all","map","configProvider","defineConfig","config","configProvider","create","app","mailers","default","defaultMailer","rest","mailersNames","Object","keys","transports","mailerName","mailerTransport","resolver","smtp","SMTPTransport","ses","SESTransport","mailgun","MailgunTransport","sparkpost","SparkPostTransport","resend","ResendTransport","brevo","BrevoTransport"]}