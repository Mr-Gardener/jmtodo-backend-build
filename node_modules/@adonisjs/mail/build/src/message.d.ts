import { Readable } from 'node:stream';
import Macroable from '@poppinss/macroable';
import type { SendMailOptions } from 'nodemailer';
import { type ICalCalendar } from 'ical-generator';
import { Attachment, ListHeader } from 'nodemailer/lib/mailer/index.js';
import type { Recipient, AttachmentOptions, NodeMailerMessage, CalendarEventOptions, MessageBodyTemplates, MailerTemplateEngine } from './types.js';
/**
 * Fluent API to construct node mailer message object
 */
export declare class Message extends Macroable {
    #private;
    static templateEngine?: MailerTemplateEngine;
    /**
     * Use the configured template engine to compute
     * the email contents from templates
     */
    static computeContentsFor({ message, views, }: {
        message: NodeMailerMessage;
        views: MessageBodyTemplates;
    }): Promise<void>;
    /**
     * Templates to use for rendering email body for
     * HTML, plain text and watch
     */
    contentViews: MessageBodyTemplates;
    /**
     * Reference to the underlying node mailer message
     */
    nodeMailerMessage: NodeMailerMessage;
    /**
     * Converts a recipient email and name to formatted
     * string
     */
    protected formatRecipient(recipient?: Recipient): string | undefined;
    /**
     * Check if a given recipient exists for the mentioned
     * email and name.
     */
    hasRecipient(property: 'to' | 'cc' | 'bcc' | 'replyTo', address: string, name?: string): boolean;
    /**
     * Assert the message is sent to the mentioned address
     */
    assertRecipient(property: 'to' | 'cc' | 'bcc' | 'replyTo', address: string, name?: string): void;
    /**
     * Add recipient as `to`
     */
    to(address: string, name?: string): this;
    /**
     * Check if message is sent to the mentioned address
     */
    hasTo(address: string, name?: string): boolean;
    /**
     * Assert the message is sent to the mentioned address
     */
    assertTo(address: string, name?: string): void;
    /**
     * Add `from` name and email
     */
    from(address: string, name?: string): this;
    /**
     * Check if message is sent from the mentioned address
     */
    hasFrom(address: string, name?: string): boolean;
    /**
     * Assert the message is sent from the mentioned address
     */
    assertFrom(address: string, name?: string): void;
    /**
     * Add recipient as `cc`
     */
    cc(addresses: string[]): this;
    cc(addresses: {
        address: string;
        name: string;
    }[]): this;
    cc(address: string, name?: string): this;
    /**
     * Check if message is sent to the mentioned address
     */
    hasCc(address: string, name?: string): boolean;
    /**
     * Assert the message is sent to the mentioned address
     */
    assertCc(address: string, name?: string): void;
    /**
     * Add recipient as `bcc`
     */
    bcc(addresses: string[]): this;
    bcc(addresses: {
        address: string;
        name: string;
    }[]): this;
    bcc(address: string, name?: string): this;
    /**
     * Check if message is sent to the mentioned address
     */
    hasBcc(address: string, name?: string): boolean;
    /**
     * Assert the message is sent to the mentioned address
     */
    assertBcc(address: string, name?: string): void;
    /**
     * Define custom message id
     */
    messageId(messageId: string): this;
    /**
     * Define subject
     */
    subject(message: string): this;
    /**
     * Check if the message has the mentioned subject
     */
    hasSubject(message: string): boolean;
    /**
     * Assert the message has the mentioned subject
     */
    assertSubject(message: string): void;
    /**
     * Define replyTo email and name
     */
    replyTo(address: string, name?: string): this;
    /**
     * Check if the mail has the mentioned reply to address
     */
    hasReplyTo(address: string, name?: string): boolean;
    /**
     * Assert the mail has the mentioned reply to address
     */
    assertReplyTo(address: string, name?: string): void;
    /**
     * Define inReplyTo message id
     */
    inReplyTo(messageId: string): this;
    /**
     * Define multiple message id's as references
     */
    references(messagesIds: string[]): this;
    /**
     * Optionally define email envolpe
     */
    envelope(envelope: SendMailOptions['envelope']): this;
    /**
     * Define contents encoding
     */
    encoding(encoding: string): this;
    /**
     * Define email prority
     */
    priority(priority: 'low' | 'normal' | 'high'): this;
    /**
     * Compute email html from defined view
     */
    htmlView(template: string, data?: any): this;
    /**
     * Compute email text from defined view
     */
    textView(template: string, data?: any): this;
    /**
     * Compute apple watch html from defined view
     */
    watchView(template: string, data?: any): this;
    /**
     * Compute email html from raw text
     */
    html(content: string): this;
    /**
     * Compute email text from raw text
     */
    text(content: string): this;
    /**
     * Compute email watch html from raw text
     */
    watch(content: string): this;
    /**
     * Assert content of mail to include substring or match
     * a given regular expression
     */
    assertContent(property: 'text' | 'watch' | 'html', substring: string | RegExp): void;
    /**
     * Assert message plain text contents to include
     * substring or match the given regular expression
     */
    assertTextIncludes(substring: string | RegExp): void;
    /**
     * Assert message HTML contents to include substring
     * or match the given regular expression
     */
    assertHtmlIncludes(substring: string | RegExp): void;
    /**
     * Assert message watch contents to include substring
     * or match the given regular expression
     */
    assertWatchIncludes(substring: string | RegExp): void;
    /**
     * Define one or attachments
     */
    attach(file: string | URL, options?: Omit<AttachmentOptions, 'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding' | 'encoding'>): this;
    /**
     * Check if a file attachment exists by the mentioned
     * file path or URL.
     */
    hasAttachment(file: string | URL, options?: {
        filename?: string;
        cid?: string;
    }): boolean;
    hasAttachment(finder: (attachment: Attachment) => boolean): boolean;
    /**
     * Assert a file attachment exists by the mentioned
     * file path or URL.
     */
    assertAttachment(file: string | URL, options?: {
        filename?: string;
        cid?: string;
    }): void;
    assertAttachment(finder: (attachment: Attachment) => boolean): void;
    /**
     * Define attachment from raw data
     */
    attachData(content: Readable | Buffer, options: Omit<AttachmentOptions, 'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding'> & {
        filename: string;
    }): this;
    /**
     * Embed attachment inside content using `cid`
     */
    embed(file: string | URL, cid: string, options?: Omit<AttachmentOptions, 'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding' | 'encoding'>): this;
    /**
     * Embed attachment from raw data inside content using `cid`
     */
    embedData(content: Readable | Buffer, cid: string, options?: Omit<AttachmentOptions, 'raw' | 'content' | 'cid' | 'path' | 'contentTransferEncoding'>): this;
    /**
     * Define custom headers for email
     */
    header(key: string, value: string | string[]): this;
    /**
     * Check if a header has been defined and optionally
     * check for values as well.
     */
    hasHeader(key: string, value?: string | string[]): boolean;
    /**
     * Assert a header has been defined and optionally
     * check for values as well.
     */
    assertHeader(key: string, value?: string | string[]): void;
    /**
     * Define custom prepared headers for email
     */
    preparedHeader(key: string, value: string): this;
    /**
     * Defines a `List-` prefix header on the email. Calling
     * this method multiple times for the same key will
     * override the old value.
     */
    addListHeader(key: string, value: ListHeader | ListHeader[] | ListHeader[][]): this;
    /**
     * Add `List-Help` header. Calling this method multiple
     * times will override the existing value
     */
    listHelp(value: ListHeader | ListHeader[] | ListHeader[][]): this;
    /**
     * Add `List-Unsubscribe` header. Calling this method multiple
     * times will override the existing value
     */
    listUnsubscribe(value: ListHeader | ListHeader[] | ListHeader[][]): this;
    /**
     * Add `List-Subscribe` header. Calling this method multiple
     * times will override the existing value
     */
    listSubscribe(value: ListHeader | ListHeader[] | ListHeader[][]): this;
    /**
     * Attach a calendar event and define contents as string
     */
    icalEvent(contents: ((calendar: ICalCalendar) => void) | string, options?: CalendarEventOptions): this;
    /**
     * Attach a calendar event and load contents from a file
     */
    icalEventFromFile(file: string | URL, options?: CalendarEventOptions): this;
    /**
     * Attach a calendar event and load contents from a url
     */
    icalEventFromUrl(url: string, options?: CalendarEventOptions): this;
    /**
     * Computes email contents by rendering the configured
     * templates
     */
    computeContents(): Promise<void>;
    /**
     * Object representation of the message
     */
    toObject(): {
        message: NodeMailerMessage;
        views: MessageBodyTemplates;
    };
    /**
     * JSON representation of the message
     */
    toJSON(): {
        message: NodeMailerMessage;
        views: MessageBodyTemplates;
    };
}
