{"version":3,"sources":["../../../src/transports/resend.ts"],"sourcesContent":["/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport got from 'got'\nimport { createTransport, type Transport } from 'nodemailer'\nimport MailMessage from 'nodemailer/lib/mailer/mail-message.js'\n\nimport debug from '../debug.js'\nimport { MailResponse } from '../mail_response.js'\nimport { E_MAIL_TRANSPORT_ERROR } from '../errors.js'\nimport type {\n  ResendConfig,\n  NodeMailerMessage,\n  MailTransportContract,\n  ResendRuntimeConfig,\n  ResendSentMessageInfo,\n} from '../types.js'\n\n/**\n * Transport for nodemailer\n */\nclass NodeMailerTransport implements Transport {\n  name = 'resend'\n  version = '1.0.0'\n\n  #config: ResendConfig\n\n  constructor(config: ResendConfig) {\n    this.#config = config\n  }\n\n  /**\n   * Formatting recipients for resend API call\n   */\n  #formatRecipients(\n    recipients?: MailMessage['data']['to'] | MailMessage['data']['cc'] | MailMessage['data']['bcc']\n  ): string[] {\n    if (!recipients) {\n      return []\n    }\n\n    /**\n     * Normalizing an array of recipients\n     */\n    if (Array.isArray(recipients)) {\n      return recipients.map((recipient) => {\n        if (typeof recipient === 'string') {\n          return recipient\n        }\n\n        if (recipient.name) {\n          return `${recipient.name} <${recipient.address}>`\n        }\n\n        return recipient.address\n      })\n    }\n\n    /**\n     * Normalizing a string based recipient\n     */\n    if (typeof recipients === 'string') {\n      return [recipients]\n    }\n\n    /**\n     * Normalizing an object based string\n     */\n    if (recipients.name) {\n      return [`${recipients.name} <${recipients.address}>`]\n    }\n\n    return [recipients.address]\n  }\n\n  /**\n   * Prepare the payload by converting Mail message to the format\n   * accepted by Resend\n   */\n  #preparePayload(mail: MailMessage) {\n    let payload: Record<string, any> = {\n      from: this.#formatRecipients(mail.data.from)[0],\n      to: this.#formatRecipients(mail.data.to),\n      subject: mail.data.subject,\n    }\n\n    if (mail.data.bcc) {\n      payload.bcc = this.#formatRecipients(mail.data.bcc)\n    }\n\n    if (mail.data.cc) {\n      payload.cc = this.#formatRecipients(mail.data.cc)\n    }\n\n    if (mail.data.replyTo) {\n      payload.reply_to = this.#formatRecipients(mail.data.replyTo)\n    }\n\n    if (mail.data.html) {\n      payload.html = mail.data.html\n    }\n\n    if (mail.data.text) {\n      payload.text = mail.data.text\n    }\n\n    if (mail.data.attachments) {\n      payload.attachments = mail.data.attachments.map((attachment) => ({\n        content: attachment.content,\n        filename: attachment.filename,\n        path: attachment.path,\n      }))\n    }\n\n    if (this.#config.tags) {\n      payload.tags = this.#config.tags\n    }\n\n    return payload\n  }\n\n  /**\n   * Returns the normalized base URL for the API\n   */\n  #getBaseUrl() {\n    return this.#config.baseUrl.replace(/\\/$/, '')\n  }\n\n  /**\n   * Send the message\n   */\n  async send(\n    mail: MailMessage,\n    callback: (err: Error | null, info: ResendSentMessageInfo) => void\n  ) {\n    const url = `${this.#getBaseUrl()}/emails`\n    const envelope = mail.message.getEnvelope()\n    const payload = this.#preparePayload(mail)\n\n    debug('resend mail url \"%s\"', url)\n    debug('resend mail payload %O', payload)\n\n    try {\n      const response = await got.post<{ id: string }>(url, {\n        responseType: 'json',\n        json: payload,\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.#config.key}`,\n        },\n      })\n\n      const resendMessageId = response.body.id\n      const messageId = resendMessageId\n        ? resendMessageId.replace(/^<|>$/g, '')\n        : mail.message.messageId()\n\n      callback(null, { messageId, envelope, ...response.body })\n    } catch (error) {\n      callback(\n        new E_MAIL_TRANSPORT_ERROR('Unable to send email using the resend transport', {\n          cause: error,\n        }),\n        undefined as any\n      )\n    }\n  }\n}\n\n/**\n * Transport for sending using the Resend `/emails` API.\n */\nexport class ResendTransport implements MailTransportContract {\n  #config: ResendConfig\n\n  constructor(config: ResendConfig) {\n    this.#config = config\n  }\n\n  /**\n   * Send message\n   */\n  async send(\n    message: NodeMailerMessage,\n    config?: ResendRuntimeConfig\n  ): Promise<MailResponse<ResendSentMessageInfo>> {\n    const sparkpostTransport = new NodeMailerTransport({ ...this.#config, ...config })\n    const transporter = createTransport<ResendSentMessageInfo>(sparkpostTransport)\n\n    const sparkPostResponse = await transporter.sendMail(message)\n    return new MailResponse(\n      sparkPostResponse.messageId,\n      sparkPostResponse.envelope,\n      sparkPostResponse\n    )\n  }\n}\n"],"mappings":"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","names":["got","createTransport","NodeMailerTransport","name","version","constructor","config","recipients","Array","isArray","map","recipient","address","mail","payload","from","data","to","subject","bcc","cc","replyTo","reply_to","html","text","attachments","attachment","content","filename","path","tags","baseUrl","replace","send","callback","url","envelope","message","getEnvelope","debug","response","got","post","responseType","json","headers","key","resendMessageId","body","id","messageId","error","E_MAIL_TRANSPORT_ERROR","cause","undefined","ResendTransport","sparkpostTransport","transporter","createTransport","sparkPostResponse","sendMail","MailResponse"]}