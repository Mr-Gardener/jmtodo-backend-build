import {
  E_MAIL_TRANSPORT_ERROR
} from "../../chunk-3EFD4MAA.js";
import {
  MailResponse
} from "../../chunk-CRXUSCKP.js";
import {
  debug_default
} from "../../chunk-ZF2M7BIF.js";
import {
  __name
} from "../../chunk-XE4OXN2W.js";

// src/transports/brevo.ts
import got from "got";
import { createTransport } from "nodemailer";
var NodeMailerTransport = class NodeMailerTransport2 {
  static {
    __name(this, "NodeMailerTransport");
  }
  name = "brevo";
  version = "1.0.0";
  #config;
  constructor(config) {
    this.#config = config;
  }
  /**
  * Format the address to be accepted by the Brevo API
  */
  #formatAddress(rawAddress) {
    if (!rawAddress) {
      throw new Error("Missing recipient address");
    }
    if (typeof rawAddress === "string") {
      return {
        email: rawAddress
      };
    }
    const address = {};
    if (rawAddress.name) address.name = rawAddress.name;
    if (rawAddress.address) address.email = rawAddress.address;
    return address;
  }
  /**
  * Format a list of addresses
  */
  #formatAddresses(rawAddresses) {
    const addresses = Array.isArray(rawAddresses) ? rawAddresses : [
      rawAddresses
    ];
    return addresses.map((address) => this.#formatAddress(address));
  }
  /**
  * Convert the Mail message to the format accepted by the Brevo API
  */
  #preparePayload(mail) {
    let payload = {
      sender: this.#formatAddress(mail.data.from),
      to: this.#formatAddresses(mail.data.to),
      subject: mail.data.subject
    };
    if (mail.data.html) {
      payload.htmlContent = mail.data.html;
    }
    if (mail.data.text) {
      payload.textContent = mail.data.text;
    }
    if (mail.data.replyTo) {
      payload.replyTo = this.#formatAddresses(mail.data.replyTo);
    }
    if (mail.data.cc) {
      payload.cc = this.#formatAddresses(mail.data.cc);
    }
    if (mail.data.bcc) {
      payload.bcc = this.#formatAddresses(mail.data.bcc);
    }
    if (this.#config.tags) {
      payload.tags = this.#config.tags;
    }
    if (this.#config.scheduledAt) {
      payload.scheduledAt = this.#config.scheduledAt;
    }
    if (mail.data.attachments) {
      payload.attachment = mail.data.attachments.map((attachment) => ({
        name: attachment.filename,
        content: attachment.content.toString("base64")
      }));
    }
    return payload;
  }
  /**
  * Returns base url for sending emails
  */
  #getBaseUrl() {
    return this.#config.baseUrl.replace(/\/$/, "");
  }
  /**
  * Send mail
  */
  async send(mail, callback) {
    const url = `${this.#getBaseUrl()}/smtp/email`;
    const envelope = mail.message.getEnvelope();
    const payload = this.#preparePayload(mail);
    debug_default("brevo email url %s", url);
    debug_default("brevo email payload %O", payload);
    try {
      const response = await got.post(url, {
        headers: {
          "accept": "application/json",
          "api-key": this.#config.key,
          "content-type": "application/json"
        },
        json: payload
      });
      const brevoMessageId = response.body.messageId;
      const messageId = brevoMessageId ? brevoMessageId.replace(/^<|>$/g, "") : mail.message.messageId();
      callback(null, {
        envelope,
        messageId
      });
    } catch (error) {
      callback(new E_MAIL_TRANSPORT_ERROR("Unable to send email using the brevo transport", {
        cause: error
      }), void 0);
    }
  }
};
var BrevoTransport = class {
  static {
    __name(this, "BrevoTransport");
  }
  #config;
  constructor(config) {
    this.#config = config;
  }
  /**
  * Send message
  */
  async send(message, config) {
    const sparkpostTransport = new NodeMailerTransport({
      ...this.#config,
      ...config
    });
    const transporter = createTransport(sparkpostTransport);
    const sparkPostResponse = await transporter.sendMail(message);
    return new MailResponse(sparkPostResponse.messageId, sparkPostResponse.envelope, sparkPostResponse);
  }
};
export {
  BrevoTransport
};
//# sourceMappingURL=brevo.js.map