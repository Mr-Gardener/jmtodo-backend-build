import {
  E_MAIL_TRANSPORT_ERROR
} from "../../chunk-3EFD4MAA.js";
import {
  MailResponse
} from "../../chunk-CRXUSCKP.js";
import {
  debug_default
} from "../../chunk-ZF2M7BIF.js";
import {
  __name
} from "../../chunk-XE4OXN2W.js";

// src/transports/resend.ts
import got from "got";
import { createTransport } from "nodemailer";
var NodeMailerTransport = class NodeMailerTransport2 {
  static {
    __name(this, "NodeMailerTransport");
  }
  name = "resend";
  version = "1.0.0";
  #config;
  constructor(config) {
    this.#config = config;
  }
  /**
  * Formatting recipients for resend API call
  */
  #formatRecipients(recipients) {
    if (!recipients) {
      return [];
    }
    if (Array.isArray(recipients)) {
      return recipients.map((recipient) => {
        if (typeof recipient === "string") {
          return recipient;
        }
        if (recipient.name) {
          return `${recipient.name} <${recipient.address}>`;
        }
        return recipient.address;
      });
    }
    if (typeof recipients === "string") {
      return [
        recipients
      ];
    }
    if (recipients.name) {
      return [
        `${recipients.name} <${recipients.address}>`
      ];
    }
    return [
      recipients.address
    ];
  }
  /**
  * Prepare the payload by converting Mail message to the format
  * accepted by Resend
  */
  #preparePayload(mail) {
    let payload = {
      from: this.#formatRecipients(mail.data.from)[0],
      to: this.#formatRecipients(mail.data.to),
      subject: mail.data.subject
    };
    if (mail.data.bcc) {
      payload.bcc = this.#formatRecipients(mail.data.bcc);
    }
    if (mail.data.cc) {
      payload.cc = this.#formatRecipients(mail.data.cc);
    }
    if (mail.data.replyTo) {
      payload.reply_to = this.#formatRecipients(mail.data.replyTo);
    }
    if (mail.data.html) {
      payload.html = mail.data.html;
    }
    if (mail.data.text) {
      payload.text = mail.data.text;
    }
    if (mail.data.attachments) {
      payload.attachments = mail.data.attachments.map((attachment) => ({
        content: attachment.content,
        filename: attachment.filename,
        path: attachment.path
      }));
    }
    if (this.#config.tags) {
      payload.tags = this.#config.tags;
    }
    return payload;
  }
  /**
  * Returns the normalized base URL for the API
  */
  #getBaseUrl() {
    return this.#config.baseUrl.replace(/\/$/, "");
  }
  /**
  * Send the message
  */
  async send(mail, callback) {
    const url = `${this.#getBaseUrl()}/emails`;
    const envelope = mail.message.getEnvelope();
    const payload = this.#preparePayload(mail);
    debug_default('resend mail url "%s"', url);
    debug_default("resend mail payload %O", payload);
    try {
      const response = await got.post(url, {
        responseType: "json",
        json: payload,
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.#config.key}`
        }
      });
      const resendMessageId = response.body.id;
      const messageId = resendMessageId ? resendMessageId.replace(/^<|>$/g, "") : mail.message.messageId();
      callback(null, {
        messageId,
        envelope,
        ...response.body
      });
    } catch (error) {
      callback(new E_MAIL_TRANSPORT_ERROR("Unable to send email using the resend transport", {
        cause: error
      }), void 0);
    }
  }
};
var ResendTransport = class {
  static {
    __name(this, "ResendTransport");
  }
  #config;
  constructor(config) {
    this.#config = config;
  }
  /**
  * Send message
  */
  async send(message, config) {
    const sparkpostTransport = new NodeMailerTransport({
      ...this.#config,
      ...config
    });
    const transporter = createTransport(sparkpostTransport);
    const sparkPostResponse = await transporter.sendMail(message);
    return new MailResponse(sparkPostResponse.messageId, sparkPostResponse.envelope, sparkPostResponse);
  }
};
export {
  ResendTransport
};
//# sourceMappingURL=resend.js.map