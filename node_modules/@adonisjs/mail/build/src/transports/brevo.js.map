{"version":3,"sources":["../../../src/transports/brevo.ts"],"sourcesContent":["/*\n * @adonisjs/mail\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport got from 'got'\nimport type { Address } from 'nodemailer/lib/mailer/index.js'\nimport { type Transport, createTransport } from 'nodemailer'\nimport type MailMessage from 'nodemailer/lib/mailer/mail-message.js'\n\nimport debug from '../debug.js'\nimport { MailResponse } from '../mail_response.js'\nimport { E_MAIL_TRANSPORT_ERROR } from '../errors.js'\nimport type {\n  BrevoConfig,\n  NodeMailerMessage,\n  BrevoRuntimeConfig,\n  BrevoSentMessageInfo,\n  MailTransportContract,\n} from '../types.js'\n\n/**\n * Transport for Nodemailer\n */\nclass NodeMailerTransport implements Transport {\n  name = 'brevo'\n  version = '1.0.0'\n\n  #config: BrevoConfig\n\n  constructor(config: BrevoConfig) {\n    this.#config = config\n  }\n\n  /**\n   * Format the address to be accepted by the Brevo API\n   */\n  #formatAddress(rawAddress: string | Address | undefined) {\n    if (!rawAddress) {\n      throw new Error('Missing recipient address')\n    }\n\n    if (typeof rawAddress === 'string') {\n      return { email: rawAddress }\n    }\n\n    const address: Record<string, string> = {}\n    if (rawAddress.name) address.name = rawAddress.name\n    if (rawAddress.address) address.email = rawAddress.address\n    return address\n  }\n\n  /**\n   * Format a list of addresses\n   */\n  #formatAddresses(rawAddresses: string | Address | Array<string | Address> | undefined) {\n    const addresses = Array.isArray(rawAddresses) ? rawAddresses : [rawAddresses]\n    return addresses.map((address) => this.#formatAddress(address))\n  }\n\n  /**\n   * Convert the Mail message to the format accepted by the Brevo API\n   */\n  #preparePayload(mail: MailMessage) {\n    let payload: Record<string, any> = {\n      sender: this.#formatAddress(mail.data.from),\n      to: this.#formatAddresses(mail.data.to),\n      subject: mail.data.subject,\n    }\n\n    if (mail.data.html) {\n      payload.htmlContent = mail.data.html\n    }\n\n    if (mail.data.text) {\n      payload.textContent = mail.data.text\n    }\n\n    if (mail.data.replyTo) {\n      payload.replyTo = this.#formatAddresses(mail.data.replyTo)\n    }\n\n    if (mail.data.cc) {\n      payload.cc = this.#formatAddresses(mail.data.cc)\n    }\n\n    if (mail.data.bcc) {\n      payload.bcc = this.#formatAddresses(mail.data.bcc)\n    }\n\n    if (this.#config.tags) {\n      payload.tags = this.#config.tags\n    }\n\n    if (this.#config.scheduledAt) {\n      payload.scheduledAt = this.#config.scheduledAt\n    }\n\n    if (mail.data.attachments) {\n      payload.attachment = mail.data.attachments.map((attachment) => ({\n        name: attachment.filename,\n        content: attachment.content!.toString('base64'),\n      }))\n    }\n\n    return payload\n  }\n\n  /**\n   * Returns base url for sending emails\n   */\n  #getBaseUrl(): string {\n    return this.#config.baseUrl.replace(/\\/$/, '')\n  }\n\n  /**\n   * Send mail\n   */\n  async send(mail: MailMessage, callback: (err: Error | null, info: BrevoSentMessageInfo) => void) {\n    const url = `${this.#getBaseUrl()}/smtp/email`\n    const envelope = mail.message.getEnvelope()\n    const payload = this.#preparePayload(mail)\n\n    debug('brevo email url %s', url)\n    debug('brevo email payload %O', payload)\n\n    try {\n      const response = await got.post<{ messageId: string }>(url, {\n        headers: {\n          'accept': 'application/json',\n          'api-key': this.#config.key,\n          'content-type': 'application/json',\n        },\n        json: payload,\n      })\n\n      const brevoMessageId = response.body.messageId\n      const messageId = brevoMessageId\n        ? brevoMessageId.replace(/^<|>$/g, '')\n        : mail.message.messageId()\n\n      callback(null, { envelope, messageId })\n    } catch (error) {\n      callback(\n        new E_MAIL_TRANSPORT_ERROR('Unable to send email using the brevo transport', {\n          cause: error,\n        }),\n        undefined as any\n      )\n    }\n  }\n}\n\n/**\n * Transport for sending emails using the Brevo `/emails/send` API.\n */\nexport class BrevoTransport implements MailTransportContract {\n  #config: BrevoConfig\n\n  constructor(config: BrevoConfig) {\n    this.#config = config\n  }\n\n  /**\n   * Send message\n   */\n  async send(\n    message: NodeMailerMessage,\n    config?: BrevoRuntimeConfig\n  ): Promise<MailResponse<BrevoSentMessageInfo>> {\n    const sparkpostTransport = new NodeMailerTransport({ ...this.#config, ...config })\n    const transporter = createTransport<BrevoSentMessageInfo>(sparkpostTransport)\n\n    const sparkPostResponse = await transporter.sendMail(message)\n    return new MailResponse(\n      sparkPostResponse.messageId,\n      sparkPostResponse.envelope,\n      sparkPostResponse\n    )\n  }\n}\n"],"mappings":"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","names":["got","createTransport","NodeMailerTransport","name","version","constructor","config","rawAddress","Error","email","address","rawAddresses","addresses","Array","isArray","map","mail","payload","sender","data","from","to","subject","html","htmlContent","text","textContent","replyTo","cc","bcc","tags","scheduledAt","attachments","attachment","filename","content","toString","baseUrl","replace","send","callback","url","envelope","message","getEnvelope","debug","response","got","post","headers","key","json","brevoMessageId","body","messageId","error","E_MAIL_TRANSPORT_ERROR","cause","undefined","BrevoTransport","sparkpostTransport","transporter","createTransport","sparkPostResponse","sendMail","MailResponse"]}